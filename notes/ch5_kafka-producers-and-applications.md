
카프카에서 데이터의 시작점은 프로듀서다. 특정 파티션에 보낸다. 

파티션으로 데이터로 보낼때 리더 파티션과 통신해야 하는데, 이때 리더 파티션은 내용을 저장하고 팔로워는 해당 내용을 복제합니다. 

자바가 아닌 언어로 구현하면 문제가 되는게 공식 라이브러리는 자바만 된다. 


### 프로듀서 내부 구조
1. ProducerRecord: 프로듀서에서 생성하는 레코드. 오프셋은 미포함. 
토픽, 파티션, 타임스템프, 메시지 키, 메시지 값을 정의할 수 있으며, 토픽과 메시지 값만 있어서 보낼 수 있긴 한다. 
2. send(): 레코드를 전송 요청 메서드.
3. Partitioner: 어느 파티션으로 전송할지 지정하는 파티셔너. 기본값으로 DefaultPartitioner로 설정됨. 
4. Accumulator: 패치로 묶어 전송할 데이터를 모으는 버퍼. 한번에 많이 보낼때 사용.
![[Screenshot 2023-08-15 at 4.21.40 PM.png]]


# 파티셔너
프로듀서API를 사용하면 UniformStickyPartitioner와 RoundRobinPartitioner 2개 파티셔너를 제공한다. 

[메시지 키가 있을 경우 동작]
두가지 파티셔너 모두 메시지가 있을 때는 메시지 키의 해시값과 파티션을 매칭하여 레코드를 전송.
- 동일한 메시지 키가 존재하는 레코드는 동일한 파티션 번호에 전달됨.
- 만약 파티션 개수가 변경될 경우 메시지 키와 파티션 번호 매칭은 깨지게 됨. 
	- 해시값이 바뀌면 파티션에 제대로 갈 수 있고 다른 곳으로 갈 수도 있다. 
	- 파티션 개수를 충분히 큰 개수로 운영하면 된다. 
	- 10개의 컨슈머를 만족하려면 10개의 파티션을 운영하면 된다.
	- 프로듀서가 초당 100개 보낼 때는 10개가 아니라 널널하게 20개 또는 50개로 하는게 좋다. 

메시지 키가 없을 때 동작
RoundRobin이 옛날거이고 이걸 개선한게 UniformSticky다. 둘 다 동일하게 전송하지만 UniformSticky가 성능이 좋다. 

RoundRobin: 
- 순회하면서 전송.
- 어큐뮤레이터에서 묶이는 정도가 적기 때문에 전송 성능이 낮음.

UniformSticky (Default):
- Batch로 묶일 때까지 기다렸다가 전송.
- 순회하는 것은 동일하다.
- RR보다 향상된 성능.

### 커스텀 파티셔너
사용자 지정 파티셔너를 지정하기 위해 Partitioner Interface를 제공한다. 

- 메시지 키가 없는 경우에는 RR, 있을 때는 U.
- messagekey가 '서울'이라면 무조건 #0번 파티션으로 보내게 할 수 있다. 


# 프로듀서 주요 옵션

필수 옵션: (default가 없는 경우)
- bootstrap.servers: 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커의 호스트 이름: 포트를 1개 이상 작성한다. 2개 이상 프로커 정보를 입력하여 일부 브로커에 이슈가 발생하더라도 넙속하는 데에 이슈가 없도록 가능하다.
- key.serializer: 레코드의 메시지 키를 직렬화하는 클래스를 지정한다.
- value.serializer: 레코드의 메시지 값을 직렬화하는 클래스를 지정한다.

프로듀서에서 레코드를 보낼 때는 직렬화를 하는데, 이를 통해서 카프카의 데이터를 브로커에게 보내서 저장할 때 세상에 존재하는 모든 데이터를 적재할 수 있다. 직렬화를 하기 때문. int든 str이든 직렬화하기 때문이다. 

Consumer에선 직렬화된 데이터를 받기 때문에 역직렬화를 할 수 있는게 필요하다. 

float나 int를 stringserializer으로 하면 오히려 더 많은 데이터 사용량을 소비하게 된다. 따라서, 이런 경우에는 커스텀으로 사용하기도 한다.

1) kafka-console-consumer로 데이터를 보지 못 하는 경우는 string이 아닌 다른 방식으로 직렬화 할때. 그래서 특수한 경우가 아니면 string serializer을 사용한다.


선택 옵션 (default값이 있는 것들)
- acks: 프로듀서가 전송한 데이터가 브로커들에 정상적으로 저장되었는지 전송 성공 여부를 확인 하는 데에 사용하는 옵션이다. 
	- Producer는 리더 브로커에 보낸다. 리더 브로커에만 저장되었는지, 팔로워에도 저장이 되었는지, 1일때는 리더 브로커에 성공했는지 여부다. 
- linger.ms: 배치를 전송하기 전까지 기다리는 최소 시간이다. 기본값은 0이다. 지연을 조금 줘서 더 많은 데이터를 전송하고 싶을 때 수정.
- retries: 브로커로부터 에러를 받고 난 뒤 재전송을 시도하는 횟수를 지정한다. 기본값은 2147483647이다.
- max.in.flight.requests.per.connection: 한 번에 요청하는 최대 커넥션 개수. 기본은 5.
- partitioner.class: 레코드를 파티션에 전송할 때 적용하는 파티셔너 클래스를 지정한다. 
- enable.idempotence: 멱등성 프로듀서로 동작할지 여부를 설정. producer와 broker가 통신할때 심각한 문제가 생겼을때, 중복해서 데이터를 보내려 할때 이것을 막는 기능. 2점대 기본값은 false. 3점대에서는 true.
- transactional.id: 프로듀서가 레코드를 전송할 때 레코드를 트랜잭션 단위로 물ㄲ을지 여부를 설정한다. 기본값은 null이다. 


# ISR (In-Sync Replicas)

acks 옵션은 중요하다. 0, 1, 또는 -1.

ISR이란 용어가 생긴 이유는 팔로워 파티션이 리더 파티션을 복제하는 시간 차이(replication lag) 덕분에 offset 차이가 발생할 수 있기 때문에 생겼다. 

acks: 얼마나 높게 신뢰성을 지정할지 정하는 옵션.
신뢰도 vs 성능.

복제 개수가 2이상인 경우에만 본다. 

**acks=0**
성능은 높지만 신뢰도는 낮다. 
프로듀서가 리더 파티션으로 데이터를 전송했을 때 리더 파티션으로 *데이터가 저장되었는지 확인하지 않는다는* 것.
데이터 전송이 일부 유실되더라도 빨리 보내야하면 이렇게 쓴다. 예: GPS.

acks=1
디폴트 옵션.
리더 파티션에만 정상적으로 적재되었는지 확인.
이 과정이 조금은 시간이 걸려서 성능은 조금 낮다. 
또한, 복제 개수가 2이상이면 유실 가능성이 존재한다. 리더에만 확인하니까.

acks=-1 (all)
처리량은 낮지만 신뢰도는 가장 높다.
프로듀서가 리더에 데이터를 저장하고 팔로워들에 대해서도 다 저장한다. 

ISR은 2로 설정해도 충분하다. 1은 의미 없다.

# 프로듀서 애플리케이션 개발하기

![[Screenshot 2023-08-15 at 10.18.53 PM.png]]
에러. 왜지.?
![[Screenshot 2023-08-15 at 10.34.18 PM.png]]
브로커를 안 띄어놓고 돌리니까 안되지.

![[Screenshot 2023-08-15 at 10.37.28 PM.png]]
브로커는 문제가 있다.

뭐지...


# 메시지 키를 가진 레코드를 전송하는 프로듀서

메시지 키를 포함한 레코드를 보내봤습니다.

`bin/kafka-consoler-consumer.sh --bootstrap-server my-kafka:9092 --topic test --property print.key=true --property key.separator="-" --from-beginning`

# 레코드에 파티션 번호를 지정하여 전송하는 프로듀서
파티션 번호를 지정하여 전송하는 프로듀서.

# 커스텀 파티셔너를 가지는 프로듀서
pangyo라는 메시지 값을 가진 메시지 키가 0번 파티션으로 무조건 가야 할때 커스텀 파티션 지정.

# 레코드 전송 결과를 확인하는 프로듀서 애플리케이션
기록을 확인하면 된다. 

# 프로듀서의 안전한 종료
producer.close()


# 퀴즈
1) 프로듀서에서 데이터를 전송할 때 반드시 배치로 묶어 전송한다 (O/**X**)

2) 메시지 키를 지정하지 않으면 RoundRobinPartitioner로 파티셔너가 지정된다 (O/**X**) [옵션값에 따라 달라진다]

3) ISR은 복제 개수가 2 이상일 경우에만 존재한다 (O/**X**) [rf 1일때도 존재]

4) acks가 all(-1)일 경우 데이터 전송 속도가 가장 빠르다 (O/**X**) [0일때]

5) min.insync.replicas=3, 복제 개수가 2일 때 가장 신뢰도 높게 데이터를 전송할 수 있다 (O/**X**)





bin/kafka-console-consumer.sh --bootstrap-server my-kafka:9092 --topic test --property print.key=true --property key.separator="-" --from-beginning

박찬길

11:16 PM

이후, 프로듀서 애플리케이션 코드가 잘 작동하는지 확인하기 위해 1. bin/zookeeper-server-start.sh config/zookeeper.properties 2. bin/kafka-server-start.sh config/server.properties 3. bin/kafka-console-consumer.sh --bootstrap-server my-kafka:9092 --topic test --from-beginning 를 터미널에서 실행하여 토픽과 레코드가 잘 생성되어 적재 되었는지 확인할 수 있다
